{"version":3,"sources":["../../../../public/plugins/input-mask/jquery.inputmask.regex.extensions.js"],"names":["$","extend","inputmask","defaults","aliases","mask","greedy","repeat","regex","regexTokens","tokenizer","quantifierFilter","definitions","validator","chrs","buffer","pos","strict","opts","regexToken","matches","isGroup","isQuantifier","isLiteral","analyseRegex","currentToken","match","m","opengroups","exec","charAt","length","push","groupToken","pop","quantifier","literal","validateRegexToken","token","fromGroup","isvalid","regexPart","openGroupCount","mndx","matchToken","quantifierMax","replace","testExp","j","exp","RegExp","test","bufferStr","openGroupCloser","k","cbuffer","slice","isValid","splice","join","i","cardinality","jQuery"],"mappings":"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","file":"jquery.inputmask.regex.extensions.js","sourcesContent":["/*\nInput Mask plugin extensions\nhttp://github.com/RobinHerbots/jquery.inputmask\nCopyright (c) 2010 - 2014 Robin Herbots\nLicensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\nVersion: 0.0.0\n\nRegex extensions on the jquery.inputmask base\nAllows for using regular expressions as a mask\n*/\n(function ($) {\n    $.extend($.inputmask.defaults.aliases, { // $(selector).inputmask(\"Regex\", { regex: \"[0-9]*\"}\n        'Regex': {\n            mask: \"r\",\n            greedy: false,\n            repeat: \"*\",\n            regex: null,\n            regexTokens: null,\n            //Thx to https://github.com/slevithan/regex-colorizer for the tokenizer regex\n            tokenizer: /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\n            quantifierFilter: /[0-9]+[^,]/,\n            definitions: {\n                'r': {\n                    validator: function (chrs, buffer, pos, strict, opts) {\n                        function regexToken() {\n                            this.matches = [];\n                            this.isGroup = false;\n                            this.isQuantifier = false;\n                            this.isLiteral = false;\n                        }\n                        function analyseRegex() {\n                            var currentToken = new regexToken(), match, m, opengroups = [];\n\n                            opts.regexTokens = [];\n\n                            // The tokenizer regex does most of the tokenization grunt work\n                            while (match = opts.tokenizer.exec(opts.regex)) {\n                                m = match[0];\n                                switch (m.charAt(0)) {\n                                    case \"[\": // Character class\n                                    case \"\\\\\":  // Escape or backreference\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(m);\n                                        } else {\n                                            currentToken.matches.push(m);\n                                        }\n                                        break;\n                                    case \"(\": // Group opening\n                                        if (!currentToken.isGroup && currentToken.matches.length > 0)\n                                            opts.regexTokens.push(currentToken);\n                                        currentToken = new regexToken();\n                                        currentToken.isGroup = true;\n                                        opengroups.push(currentToken);\n                                        break;\n                                    case \")\": // Group closing\n                                        var groupToken = opengroups.pop();\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(groupToken);\n                                        } else {\n                                            opts.regexTokens.push(groupToken);\n                                            currentToken = new regexToken();\n                                        }\n                                        break;\n                                    case \"{\": //Quantifier\n                                        var quantifier = new regexToken();\n                                        quantifier.isQuantifier = true;\n                                        quantifier.matches.push(m);\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(quantifier);\n                                        } else {\n                                            currentToken.matches.push(quantifier);\n                                        }\n                                        break;\n                                    default:\n                                        // Vertical bar (alternator) \n                                        // ^ or $ anchor\n                                        // Dot (.)\n                                        // Literal character sequence\n                                        var literal = new regexToken();\n                                        literal.isLiteral = true;\n                                        literal.matches.push(m);\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(literal);\n                                        } else {\n                                            currentToken.matches.push(literal);\n                                        }\n                                }\n                            }\n\n                            if (currentToken.matches.length > 0)\n                                opts.regexTokens.push(currentToken);\n                        }\n                        function validateRegexToken(token, fromGroup) {\n                            var isvalid = false;\n                            if (fromGroup) {\n                                regexPart += \"(\";\n                                openGroupCount++;\n                            }\n                            for (var mndx = 0; mndx < token[\"matches\"].length; mndx++) {\n                                var matchToken = token[\"matches\"][mndx];\n                                if (matchToken[\"isGroup\"] == true) {\n                                    isvalid = validateRegexToken(matchToken, true);\n                                } else if (matchToken[\"isQuantifier\"] == true) {\n                                    matchToken = matchToken[\"matches\"][0];\n                                    var quantifierMax = opts.quantifierFilter.exec(matchToken)[0].replace(\"}\", \"\");\n                                    var testExp = regexPart + \"{1,\" + quantifierMax + \"}\"; //relax quantifier validation\n                                    for (var j = 0; j < openGroupCount; j++) {\n                                        testExp += \")\";\n                                    }\n                                    var exp = new RegExp(\"^(\" + testExp + \")$\");\n                                    isvalid = exp.test(bufferStr);\n                                    regexPart += matchToken;\n                                } else if (matchToken[\"isLiteral\"] == true) {\n                                    matchToken = matchToken[\"matches\"][0];\n                                    var testExp = regexPart, openGroupCloser = \"\";\n                                    for (var j = 0; j < openGroupCount; j++) {\n                                        openGroupCloser += \")\";\n                                    }\n                                    for (var k = 0; k < matchToken.length; k++) { //relax literal validation\n                                        testExp = (testExp + matchToken[k]).replace(/\\|$/, \"\");\n                                        var exp = new RegExp(\"^(\" + testExp + openGroupCloser + \")$\");\n                                        isvalid = exp.test(bufferStr);\n                                        if (isvalid) break;\n                                    }\n                                    regexPart += matchToken;\n                                    //console.log(bufferStr + \" \" + exp + \" \" + isvalid);\n                                } else {\n                                    regexPart += matchToken;\n                                    var testExp = regexPart.replace(/\\|$/, \"\");\n                                    for (var j = 0; j < openGroupCount; j++) {\n                                        testExp += \")\";\n                                    }\n                                    var exp = new RegExp(\"^(\" + testExp + \")$\");\n                                    isvalid = exp.test(bufferStr);\n                                    //console.log(bufferStr + \" \" + exp + \" \" + isvalid);\n                                }\n                                if (isvalid) break;\n                            }\n\n                            if (fromGroup) {\n                                regexPart += \")\";\n                                openGroupCount--;\n                            }\n\n                            return isvalid;\n                        }\n\n\n                        if (opts.regexTokens == null) {\n                            analyseRegex();\n                        }\n\n                        var cbuffer = buffer.slice(), regexPart = \"\", isValid = false, openGroupCount = 0;\n                        cbuffer.splice(pos, 0, chrs);\n                        var bufferStr = cbuffer.join('');\n                        for (var i = 0; i < opts.regexTokens.length; i++) {\n                            var regexToken = opts.regexTokens[i];\n                            isValid = validateRegexToken(regexToken, regexToken[\"isGroup\"]);\n                            if (isValid) break;\n                        }\n\n                        return isValid;\n                    },\n                    cardinality: 1\n                }\n            }\n        }\n    });\n})(jQuery);\n"]}